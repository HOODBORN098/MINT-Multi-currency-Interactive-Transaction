"""
ChainPay REST API Server
=========================
FastAPI backend that exposes all ChainPay functionality over HTTPS.
Your laptop runs this; all desktop and mobile clients connect to it.

Usage:
    python server.py

    For development (HTTP):
        uvicorn server:app --host 0.0.0.0 --port 8443 --reload

    For production (HTTPS with self-signed cert):
        python server.py
        (generates certs automatically on first run if not present)

API Docs (auto-generated by FastAPI):
    http://localhost:8443/docs
"""

import sys
import os
import time
import json
import subprocess

# ── Path setup: allows importing core/ modules ────────────────────────────────
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from fastapi import (
    FastAPI, Depends, HTTPException, Request, Query, Path as FPath
)
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from fastapi.responses import JSONResponse
from pydantic import BaseModel, validator, Field
from typing import Optional, List
import uvicorn

from core import database as db
from core.database import init_db
from core.wallet import WalletService, FXEngine, calculate_fee, format_amount
from core.security import (
    get_session_manager, verify_password, hash_password, generate_keypair
)
from core.blockchain import get_blockchain


# ── Startup: init DB ──────────────────────────────────────────────────────────
init_db()

# Seed demo users if they don't exist
if not db.get_user_by_phone("+254700000000"):
    priv, pub = generate_keypair()
    db.create_user("+254700000000", "Demo User",   hash_password("1234"), pub, priv, role="user")

if not db.get_user_by_phone("+254700000001"):
    priv, pub = generate_keypair()
    db.create_user("+254700000001", "Alice Kamau", hash_password("5678"), pub, priv, role="user")

if not db.get_user_by_phone("+254700000099"):
    priv, pub = generate_keypair()
    db.create_user("+254700000099", "Admin User",  hash_password("admin123"), pub, priv, role="admin")


# ── App ───────────────────────────────────────────────────────────────────────
app = FastAPI(
    title="ChainPay API",
    version="2.0.0",
    description="Blockchain-powered mobile money — REST API"
)

bearer = HTTPBearer(auto_error=True)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],          # Lock down to your domain in production
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


# ── Auth dependencies ─────────────────────────────────────────────────────────

def require_auth(
    creds: HTTPAuthorizationCredentials = Depends(bearer)
) -> dict:
    """Verify JWT token. Returns token payload on success."""
    sm      = get_session_manager()
    payload = sm.verify_token(creds.credentials)
    if not payload:
        raise HTTPException(status_code=401, detail="Invalid or expired token")
    # Check user is not suspended mid-session
    user = db.get_user_by_id(payload["sub"])
    if not user or user.get("is_suspended"):
        raise HTTPException(status_code=403, detail="Account suspended or not found")
    return payload


def require_admin(payload: dict = Depends(require_auth)) -> dict:
    """Require admin or compliance role. Used on all /admin/* routes."""
    if payload.get("role") not in ("admin", "compliance"):
        raise HTTPException(status_code=403, detail="Admin access required")
    return payload


def require_strict_admin(payload: dict = Depends(require_auth)) -> dict:
    """Require strict admin role (not compliance) for destructive actions."""
    if payload.get("role") != "admin":
        raise HTTPException(status_code=403, detail="Admin access required")
    return payload


# ── Request / Response Models ─────────────────────────────────────────────────

WEAK_PINS = {"0000", "1111", "2222", "3333", "4444", "5555",
             "6666", "7777", "8888", "9999", "1234", "4321",
             "0123", "9876", "1122", "2211", "1212"}


class RegisterRequest(BaseModel):
    phone: str = Field(..., min_length=7, max_length=20)
    name:  str = Field(..., min_length=2, max_length=80)
    pin:   str = Field(..., min_length=4, max_length=12)

    @validator("pin")
    def pin_strength(cls, v):
        if not v.isdigit():
            raise ValueError("PIN must be digits only")
        if v in WEAK_PINS:
            raise ValueError("PIN is too weak. Avoid sequential or repeated digits.")
        return v

    @validator("phone")
    def phone_format(cls, v):
        v = v.strip()
        if not v.startswith("+"):
            raise ValueError("Phone must start with country code (e.g. +254...)")
        if not v[1:].replace(" ", "").isdigit():
            raise ValueError("Phone number is invalid")
        return v


class LoginRequest(BaseModel):
    phone: str
    pin:   str


class ChangePinRequest(BaseModel):
    old_pin: str = Field(..., min_length=4)
    new_pin: str = Field(..., min_length=4, max_length=12)

    @validator("new_pin")
    def pin_strength(cls, v):
        if not v.isdigit():
            raise ValueError("PIN must be digits only")
        if v in WEAK_PINS:
            raise ValueError("PIN is too weak")
        return v


class SendRequest(BaseModel):
    recipient_phone: str
    amount:          float = Field(..., gt=0)
    currency:        str   = Field(..., min_length=3, max_length=3)
    note:            str   = Field("", max_length=140)


class ConvertRequest(BaseModel):
    from_currency: str = Field(..., min_length=3, max_length=3)
    to_currency:   str = Field(..., min_length=3, max_length=3)
    amount:        float = Field(..., gt=0)


class DepositRequest(BaseModel):
    amount:   float = Field(..., gt=0)
    currency: str   = Field(..., min_length=3, max_length=3)


class WithdrawRequest(BaseModel):
    amount:   float = Field(..., gt=0)
    currency: str   = Field(..., min_length=3, max_length=3)


class SetRoleRequest(BaseModel):
    role: str = Field(..., pattern="^(user|admin|compliance)$")


# ── Health ────────────────────────────────────────────────────────────────────

@app.get("/health")
def health():
    return {"status": "ok", "version": "2.0.0", "time": time.time()}


# ── AUTH ROUTES ───────────────────────────────────────────────────────────────

@app.post("/api/v1/auth/register")
def register(req: RegisterRequest):
    if db.get_user_by_phone(req.phone):
        raise HTTPException(400, "Phone number already registered")

    priv, pub  = generate_keypair()
    pin_hash   = hash_password(req.pin)
    user_id    = db.create_user(req.phone, req.name, pin_hash, pub, priv, role="user")

    return {"message": "Account created successfully", "user_id": user_id}


@app.post("/api/v1/auth/login")
def login(req: LoginRequest, request: Request):
    sm     = get_session_manager()
    ip     = request.client.host if request.client else ""
    phone  = req.phone.strip()

    # ── DB-persisted brute-force lockout ──────────────────────────────────
    max_attempts = int(db.get_config("max_failed_login") or "5")
    lockout_secs = int(db.get_config("lockout_seconds")  or "300")
    failed_count = db.get_failed_login_count(phone, window_seconds=lockout_secs)

    if failed_count >= max_attempts:
        db.record_login_attempt(phone, success=False, ip_hash=ip)
        raise HTTPException(
            status_code=429,
            detail=f"Account locked after {max_attempts} failed attempts. "
                   f"Try again in {lockout_secs // 60} minutes."
        )

    # ── Lookup and verify ─────────────────────────────────────────────────
    user = db.get_user_by_phone(phone)

    if not user or not verify_password(req.pin, user["pin_hash"]):
        db.record_login_attempt(phone, success=False, ip_hash=ip)
        raise HTTPException(status_code=401, detail="Invalid phone number or PIN")

    if user.get("is_suspended"):
        db.record_login_attempt(phone, success=False, ip_hash=ip)
        raise HTTPException(status_code=403, detail="Account suspended. Contact support.")

    # ── Success ───────────────────────────────────────────────────────────
    db.record_login_attempt(phone, success=True, ip_hash=ip)
    db.update_last_login(user["user_id"])
    sm.clear_failed_attempts(phone)

    token = sm.create_token(user["user_id"], phone, user.get("role_id", "user"))

    return {
        "token": token,
        "user": {
            "user_id":  user["user_id"],
            "name":     user["name"],
            "phone":    user["phone"],
            "role":     user.get("role_id", "user"),
            "kyc_status": user.get("kyc_status", "VERIFIED"),
        }
    }


@app.post("/api/v1/auth/change-pin")
def change_pin(req: ChangePinRequest, payload: dict = Depends(require_auth)):
    """
    PIN change flow:
    1. Verify current PIN matches stored hash
    2. Validate new PIN strength
    3. Hash new PIN with fresh salt
    4. Store and audit
    """
    user = db.get_user_by_id(payload["sub"])
    if not user:
        raise HTTPException(404, "User not found")

    if not verify_password(req.old_pin, user["pin_hash"]):
        # Record this as a failed attempt to prevent brute-force PIN changes
        db.record_login_attempt(user["phone"], success=False)
        raise HTTPException(401, "Current PIN is incorrect")

    if req.old_pin == req.new_pin:
        raise HTTPException(400, "New PIN must be different from current PIN")

    new_hash = hash_password(req.new_pin)
    db.update_pin(payload["sub"], new_hash)
    db.audit_action(payload["sub"], "PIN_CHANGED", {})

    return {"message": "PIN changed successfully"}


# ── WALLET ROUTES ─────────────────────────────────────────────────────────────

@app.get("/api/v1/wallet/balances")
def get_balances(payload: dict = Depends(require_auth)):
    wallets = db.get_all_wallets(payload["sub"])
    return {"wallets": wallets}


@app.post("/api/v1/wallet/send")
def send_money(req: SendRequest, payload: dict = Depends(require_auth)):
    ok, msg, data = WalletService.send_money(
        payload["sub"], req.recipient_phone,
        req.amount, req.currency.upper(), req.note
    )
    if not ok:
        raise HTTPException(400, msg)
    return {"message": msg, "transaction": data}


@app.post("/api/v1/wallet/convert")
def convert_currency(req: ConvertRequest, payload: dict = Depends(require_auth)):
    """
    Atomic currency conversion.
    Debit from_currency → Credit to_currency in single DB transaction.
    Rollback on any failure. Logged to blockchain and audit trail.
    """
    if req.from_currency.upper() == req.to_currency.upper():
        raise HTTPException(400, "Cannot convert to the same currency")

    ok, msg, data = WalletService.convert_currency(
        payload["sub"],
        req.from_currency.upper(),
        req.to_currency.upper(),
        req.amount
    )
    if not ok:
        raise HTTPException(400, msg)
    return {"message": msg, "conversion": data}


@app.post("/api/v1/wallet/deposit")
def deposit(req: DepositRequest, payload: dict = Depends(require_auth)):
    ok, msg, data = WalletService.deposit(
        payload["sub"], req.amount, req.currency.upper()
    )
    if not ok:
        raise HTTPException(400, msg)
    return {"message": msg, "transaction": data}


@app.post("/api/v1/wallet/withdraw")
def withdraw(req: WithdrawRequest, payload: dict = Depends(require_auth)):
    ok, msg, data = WalletService.withdraw(
        payload["sub"], req.amount, req.currency.upper()
    )
    if not ok:
        raise HTTPException(400, msg)
    return {"message": msg, "transaction": data}


@app.get("/api/v1/wallet/transactions")
def get_transactions(
    limit: int = Query(default=50, ge=1, le=200),
    payload: dict = Depends(require_auth)
):
    txs = db.get_user_transactions(payload["sub"], limit=limit)
    return {"transactions": txs}


# ── FX ROUTES ─────────────────────────────────────────────────────────────────

@app.get("/api/v1/fx/rates")
def get_fx_rates():
    """Public endpoint — no auth required for rate display."""
    rates = FXEngine.get_rate_table()
    return {"rates": rates}


@app.get("/api/v1/fx/quote")
def get_fx_quote(
    from_ccy: str = Query(..., alias="from"),
    to_ccy:   str = Query(..., alias="to"),
    amount:   float = Query(..., gt=0)
):
    """Get a conversion quote without executing it."""
    quote = FXEngine.get_conversion_quote(
        from_ccy.upper(), to_ccy.upper(), amount
    )
    if not quote:
        raise HTTPException(400, f"FX rate not available for {from_ccy}/{to_ccy}")
    return quote


# ── BLOCKCHAIN ROUTES ─────────────────────────────────────────────────────────

@app.get("/api/v1/blockchain/stats")
def blockchain_stats(payload: dict = Depends(require_auth)):
    return get_blockchain().get_chain_stats()


@app.get("/api/v1/blockchain/blocks")
def blockchain_blocks(
    n: int = Query(default=20, ge=1, le=100),
    payload: dict = Depends(require_auth)
):
    return {"blocks": get_blockchain().get_recent_blocks(n)}


@app.post("/api/v1/blockchain/mine")
def mine_block(payload: dict = Depends(require_auth)):
    block = get_blockchain().mine_block(force=True)
    if block:
        return {
            "message":      "Block mined",
            "block_index":  block.index,
            "block_hash":   block.block_hash[:32] + "...",
            "tx_count":     len(block.transactions),
        }
    return {"message": "No pending transactions to mine"}


@app.get("/api/v1/blockchain/validate")
def validate_chain(payload: dict = Depends(require_auth)):
    valid, msg = get_blockchain().validate_chain()
    return {"valid": valid, "message": msg}


# ── ADMIN ROUTES ──────────────────────────────────────────────────────────────
# ALL routes below require require_admin or require_strict_admin.
# Normal users get HTTP 403 if they call these — even with a valid token.

@app.get("/api/v1/admin/stats")
def admin_stats(payload: dict = Depends(require_admin)):
    return db.get_system_stats()


@app.get("/api/v1/admin/tx-stats")
def admin_tx_stats(payload: dict = Depends(require_admin)):
    return db.get_tx_stats()


@app.get("/api/v1/admin/system-balances")
def admin_system_balances(payload: dict = Depends(require_admin)):
    return db.get_total_system_balances()


@app.get("/api/v1/admin/users")
def admin_get_users(payload: dict = Depends(require_admin)):
    return {"users": db.get_all_users()}


@app.post("/api/v1/admin/users/{user_id}/suspend")
def admin_suspend(
    user_id: str = FPath(...),
    payload: dict = Depends(require_strict_admin)
):
    if user_id == payload["sub"]:
        raise HTTPException(400, "Cannot suspend yourself")
    db.suspend_user(user_id, payload["sub"], "Admin action via API")
    return {"message": "User suspended"}


@app.post("/api/v1/admin/users/{user_id}/unsuspend")
def admin_unsuspend(
    user_id: str = FPath(...),
    payload: dict = Depends(require_strict_admin)
):
    db.unsuspend_user(user_id, payload["sub"])
    return {"message": "User unsuspended"}


@app.post("/api/v1/admin/users/{user_id}/role")
def admin_set_role(
    req: SetRoleRequest,
    user_id: str = FPath(...),
    payload: dict = Depends(require_strict_admin)
):
    if user_id == payload["sub"] and req.role != "admin":
        raise HTTPException(400, "Cannot demote yourself")
    db.set_user_role(user_id, req.role, payload["sub"])
    return {"message": f"Role updated to {req.role}"}


@app.get("/api/v1/admin/suspicious")
def admin_suspicious(payload: dict = Depends(require_admin)):
    return {"flags": db.get_suspicious_activity(resolved=False)}


@app.post("/api/v1/admin/flags/{flag_id}/resolve")
def admin_resolve_flag(
    flag_id: str = FPath(...),
    payload: dict = Depends(require_admin)
):
    db.resolve_suspicious_flag(flag_id, payload["sub"])
    return {"message": "Flag resolved"}


@app.get("/api/v1/admin/login-attempts")
def admin_login_attempts(
    limit: int = Query(default=100, ge=1, le=500),
    payload: dict = Depends(require_admin)
):
    return {"attempts": db.get_login_attempts(limit=limit)}


@app.get("/api/v1/admin/audit-log")
def admin_audit_log(
    limit: int = Query(default=100, ge=1, le=500),
    payload: dict = Depends(require_admin)
):
    return {"log": db.get_audit_log(limit=limit)}


@app.get("/api/v1/admin/config")
def admin_get_config(payload: dict = Depends(require_admin)):
    return {"config": db.get_all_config()}


@app.get("/api/v1/admin/blockchain-txs")
def admin_blockchain_txs(
    limit: int = Query(default=30, ge=1, le=200),
    payload: dict = Depends(require_admin)
):
    bc  = get_blockchain()
    txs = list(reversed(list(bc.tx_index.values())[-limit:]))
    return {"transactions": txs}


# ── Error handlers ────────────────────────────────────────────────────────────

@app.exception_handler(Exception)
async def global_exception_handler(request: Request, exc: Exception):
    """Catch-all: never leak stack traces to clients."""
    return JSONResponse(
        status_code=500,
        content={"detail": "Internal server error. Check server logs."}
    )


# ── TLS cert auto-generation ──────────────────────────────────────────────────

# ── TLS cert auto-generation ──────────────────────────────────────────────────

# ── TLS cert auto-generation ──────────────────────────────────────────────────

def _ensure_certs():
    """
    Auto-generate a self-signed certificate if none exists.
    Uses cryptography library for reliable cross-platform generation.
    """
    cert_dir  = os.path.join(os.path.dirname(__file__), "certs")
    key_file  = os.path.join(cert_dir, "key.pem")
    cert_file = os.path.join(cert_dir, "cert.pem")

    if os.path.exists(key_file) and os.path.exists(cert_file):
        # Verify the files are valid
        try:
            # Try to load the cert to verify it's valid
            import ssl
            ctx = ssl.create_default_context()
            ctx.load_cert_chain(cert_file, key_file)
            return key_file, cert_file
        except Exception:
            # If certs are invalid, delete them and regenerate
            print("Certificate files exist but are invalid. Regenerating...")
            try:
                os.remove(key_file)
                os.remove(cert_file)
            except Exception:
                pass

    os.makedirs(cert_dir, exist_ok=True)
    print("Generating self-signed TLS certificate...")
    
    try:
        from cryptography import x509
        from cryptography.x509.oid import NameOID
        from cryptography.hazmat.primitives import hashes, serialization
        from cryptography.hazmat.primitives.asymmetric import rsa
        import datetime
        import ipaddress
        
        # Generate private key
        private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=2048,
        )
        
        # Generate certificate
        subject = issuer = x509.Name([
            x509.NameAttribute(NameOID.COMMON_NAME, u"chainpay-server"),
        ])
        
        # Fix: Use datetime.now(timezone.utc) instead of deprecated utcnow()
        import datetime as dt
        from datetime import timezone
        
        # Create the certificate builder
        cert_builder = x509.CertificateBuilder().subject_name(
            subject
        ).issuer_name(
            issuer
        ).public_key(
            private_key.public_key()
        ).serial_number(
            x509.random_serial_number()
        ).not_valid_before(
            dt.datetime.now(timezone.utc)
        ).not_valid_after(
            dt.datetime.now(timezone.utc) + dt.timedelta(days=365)
        )
        
        # Add SAN extension with proper IPAddress objects
        cert_builder = cert_builder.add_extension(
            x509.SubjectAlternativeName([
                x509.DNSName(u"localhost"),
                x509.DNSName(u"127.0.0.1"),  # DNSName works with IP strings too
                x509.IPAddress(ipaddress.IPv4Address("127.0.0.1")),
                x509.IPAddress(ipaddress.IPv4Address("0.0.0.0")),
            ]),
            critical=False,
        )
        
        # Sign the certificate
        cert = cert_builder.sign(private_key, hashes.SHA256())
        
        # Write private key
        with open(key_file, "wb") as f:
            f.write(private_key.private_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PrivateFormat.PKCS8,
                encryption_algorithm=serialization.NoEncryption(),
            ))
        
        # Write certificate
        with open(cert_file, "wb") as f:
            f.write(cert.public_bytes(serialization.Encoding.PEM))
        
        print(f"✓ Certificate generated successfully: {cert_file}")
        return key_file, cert_file
        
    except ImportError as e:
        print(f"WARNING: Could not generate certificates: {e}")
        print("Falling back to HTTP mode.")
        return None, None
    except Exception as e:
        print(f"WARNING: Certificate generation failed: {e}")
        print("Falling back to HTTP mode.")
        return None, None

# ── Database helper additions ─────────────────────────────────────────────────
# These functions are called by server.py routes but may not exist in the
# original database.py. We patch them in here safely.

def _patch_db():
    """Patch missing functions into the db module without touching database.py."""
    import time as _time

    if not hasattr(db, "update_pin"):
        def update_pin(user_id: str, new_pin_hash: str):
            with db.get_db() as conn:
                conn.execute(
                    "UPDATE users SET pin_hash=? WHERE user_id=?",
                    (new_pin_hash, user_id)
                )
        db.update_pin = update_pin

    if not hasattr(db, "get_user_wallets"):
        db.get_user_wallets = db.get_all_wallets


_patch_db()


# ── Entry point ───────────────────────────────────────────────────────────────

# ── Entry point ───────────────────────────────────────────────────────────────

if __name__ == "__main__":
    HOST     = "0.0.0.0"
    PORT     = 8443
    USE_HTTP = os.environ.get("CHAINPAY_HTTP", "").lower() in ("1", "true", "yes")

    if USE_HTTP:
        # Plain HTTP — for development or behind a reverse proxy
        print(f"\n  ChainPay API Server (HTTP)")
        print(f"  Running on http://{HOST}:{PORT}")
        print(f"  API docs: http://localhost:{PORT}/docs\n")
        uvicorn.run(
            "server:app",
            host=HOST,
            port=PORT,
            reload=False,
            workers=1,
            log_level="info",
        )
    else:
        # HTTPS — generate cert if needed
        key_file, cert_file = _ensure_certs()
        if key_file and cert_file and os.path.exists(key_file) and os.path.exists(cert_file):
            try:
                print(f"\n  ChainPay API Server (HTTPS)")
                print(f"  Running on https://{HOST}:{PORT}")
                print(f"  API docs: https://localhost:{PORT}/docs")
                print(f"  TLS cert: {cert_file}\n")
                uvicorn.run(
                    "server:app",
                    host=HOST,
                    port=PORT,
                    ssl_keyfile=key_file,
                    ssl_certfile=cert_file,
                    reload=False,
                    workers=1,       # MUST be 1 for SQLite
                    log_level="info",
                )
            except Exception as e:
                print(f"\n⚠️  HTTPS startup failed: {e}")
                print("Falling back to HTTP mode...\n")
                uvicorn.run(
                    "server:app",
                    host=HOST,
                    port=PORT,
                    reload=False,
                    workers=1,
                    log_level="info",
                )
        else:
            # Fallback to HTTP if cert generation failed
            print(f"\n  ChainPay API Server (HTTP fallback — could not create TLS certificates)")
            print(f"  Running on http://{HOST}:{PORT}\n")
            uvicorn.run(
                "server:app",
                host=HOST,
                port=PORT,
                reload=False,
                workers=1,
                log_level="info",
            )